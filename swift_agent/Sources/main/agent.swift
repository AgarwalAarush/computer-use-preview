






























































import Foundation































import GoogleGenerativeAI































































@available(macOS 11.0, *)































class BrowserAgent {































    let browserComputer: Computer































    let query: String































    let modelName: String































    let verbose: Bool































    var finalReasoning: String?































    let model: GenerativeModel































    var contents: [ModelContent] = []































































    init(browserComputer: Computer, query: String, modelName: String, verbose: Bool = true) {































        self.browserComputer = browserComputer































        self.query = query































        self.modelName = modelName































        self.verbose = verbose































        self.model = GenerativeModel(name: modelName, apiKey: ProcessInfo.processInfo.environment["GEMINI_API_KEY"] ?? "")































        let guidanceText = "You are controlling an existing computer session. Only launch a web browser when the user's request explicitly requires it or when the browser is already the active window. Otherwise, continue working within the currently visible applications. Follow the user's instructions literally and avoid performing extra steps beyond what is requested."































        self.contents.append(ModelContent(role: "user", parts: [.text(guidanceText)]))































        self.contents.append(ModelContent(role: "user", parts: [.text(query)]))































    }































































    func agentLoop() {































        Task {































            var status = "CONTINUE"































            while status == "CONTINUE" {































                status = await runOneIteration()































            }































        }































    }































































    func runOneIteration() async -> String {































        do {































            let response = try await model.generateContent(contents)































            guard let candidate = response.candidates.first else {































                print("Response has no candidates!")































                return "COMPLETE"































            }































































            contents.append(candidate.content)































































            let reasoning = getText(candidate: candidate)































            let functionCalls = extractFunctionCalls(candidate: candidate)































































            if functionCalls.isEmpty {































                print("Agent Loop Complete: \(reasoning ?? "")")































                finalReasoning = reasoning































                return "COMPLETE"































            }































































            var functionResponses: [ModelContent.Part] = []































            for functionCall in functionCalls {































                let functionResponse = handleAction(action: functionCall)































                functionResponses.append(.functionResponse(functionResponse))































            }































            contents.append(ModelContent(role: "user", parts: functionResponses))































































            return "CONTINUE"































        } catch {































            print("Error generating content: \(error)")































            return "COMPLETE"































        }































    }































































    func handleAction(action: FunctionCall) -> FunctionResponse {































        let args = action.args































        let envState: EnvState































        switch action.name {































        case "click_at":































            let x = denormalizeX(getInt(from: args["x"]))































            let y = denormalizeY(getInt(from: args["y"]))































            envState = browserComputer.clickAt(x: x, y: y)































        case "hover_at":































            let x = denormalizeX(getInt(from: args["x"]))































            let y = denormalizeY(getInt(from: args["y"]))































            envState = browserComputer.hoverAt(x: x, y: y)































        case "type_text_at":































            let x = denormalizeX(getInt(from: args["x"]))































            let y = denormalizeY(getInt(from: args["y"]))































            let text = getString(from: args["text"])































            let pressEnter = getBool(from: args["press_enter"]) ?? false































            let clearBeforeTyping = getBool(from: args["clear_before_typing"]) ?? true































            envState = browserComputer.typeTextAt(x: x, y: y, text: text, pressEnter: pressEnter, clearBeforeTyping: clearBeforeTyping)































        case "scroll_document":































            let direction = getString(from: args["direction"])































            envState = browserComputer.scrollDocument(direction: direction)































        case "scroll_at":































            let x = denormalizeX(getInt(from: args["x"]))































            let y = denormalizeY(getInt(from: args["y"]))































            let direction = getString(from: args["direction"])































            let magnitude = getInt(from: args["magnitude"])































            envState = browserComputer.scrollAt(x: x, y: y, direction: direction, magnitude: magnitude)































        case "wait_5_seconds":































            envState = browserComputer.wait5Seconds()































        case "go_back":































            envState = browserComputer.goBack()































        case "go_forward":































            envState = browserComputer.goForward()































        case "search":































            envState = browserComputer.search()































        case "navigate":































            let url = getString(from: args["url"])































            envState = browserComputer.navigate(url: url)































        case "key_combination":































            let keys = getString(from: args["keys"])































            envState = browserComputer.keyCombination(keys: keys.components(separatedBy: "+"))































        case "drag_and_drop":































            let x = denormalizeX(getInt(from: args["x"]))































            let y = denormalizeY(getInt(from: args["y"]))































            let destinationX = denormalizeX(getInt(from: args["destination_x"]))































            let destinationY = denormalizeY(getInt(from: args["destination_y"]))































            envState = browserComputer.dragAndDrop(x: x, y: y, destinationX: destinationX, destinationY: destinationY)































        default:































            fatalError("Unsupported function: \(action.name)")































        }































        return FunctionResponse(name: action.name, response: envState.toFunctionResponse())































    }































































    func denormalizeX(_ x: Int) -> Int {































        let (width, _) = browserComputer.screenSize()































        return Int(Double(x) / 1000.0 * Double(width))































    }































































    func denormalizeY(_ y: Int) -> Int {































        let (_, height) = browserComputer.screenSize()































        return Int(Double(y) / 1000.0 * Double(height))































    }































































    func getText(candidate: CandidateResponse) -> String? {































        return candidate.content.parts.compactMap { $0.text }.joined(separator: " ")































    }































































    func extractFunctionCalls(candidate: CandidateResponse) -> [FunctionCall] {































        return candidate.content.parts.compactMap { part in































            guard case .functionCall(let functionCall) = part else {































                return nil































            }































            return functionCall































        }































    }































































    private func getInt(from value: JSONValue?) -> Int {































        guard let value = value else { return 0 }































        if case .number(let number) = value {































            return Int(number)































        }































        return 0































    }































































    private func getString(from value: JSONValue?) -> String {































        guard let value = value else { return "" }































        if case .string(let string) = value {































            return string































        }































        return ""































    }































































    private func getBool(from value: JSONValue?) -> Bool? {































        guard let value = value else { return nil }































        if case .bool(let bool) = value {































            return bool































        }































        return nil































    }































}































































extension EnvState {































    func toFunctionResponse() -> [String: JSONValue] {































        return [































            "url": .string(url),































            "screenshot": .string(screenshot.base64EncodedString())































        ]































    }































}






























































